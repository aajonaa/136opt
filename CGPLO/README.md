# Centroid-Generative Particle Light Optimization
1. Comparison of Optimal Solutions of Clusters  Created Using Clustering Algorithm with MetaHeuristic Algorithms in Capacity Vehicle Routing  Problem
2. Enhancing Dynamic Constrained Multi-objective  Optimization with Multi-centers based Prediction

**Summary of Changes and Integration:**

1.  **Function Name:** Changed to `CGPLO_BSA` to reflect the integration.
2.  **BSA Parameters:** Added `DIM_RATE_bsa`, `history_update_prob_bsa`, and `map_strategy_prob_bsa` as internal parameters.
3.  **`historyX_cgplo`:**
    * Initialized using the `initialization` function or with the sorted initial population `X`.
    * Updated at the beginning of each main loop iteration: `if rand < history_update_prob_bsa; historyX_cgplo = X; end` followed by `historyX_cgplo = historyX_cgplo(randperm(N),:);`.
4.  **BSA Recombination Step:**
    * Added as the last operator before evaluation of `current_newX`.
    * Generates `map_bsa` based on `DIM_RATE_bsa` and `map_strategy_prob_bsa`.
    * Calls `get_scale_factor_bsa()` to get `F_bsa`.
    * Updates `current_newX` using the formula: `current_newX = current_newX + (map_bsa.*F_bsa).*(historyX_cgplo - current_newX);`.
    * Applies `BoundaryControl_bsa()` to the result.
5.  **Helper Functions for BSA:**
    * `get_scale_factor_bsa()`: Copied from the BSA example (using the default `3*randn`).
    * `BoundaryControl_bsa()`: Adapted from the BSA example, ensuring `lb` and `ub` are handled correctly as vectors.
6.  **Minor Fixes in Map Generation:** Ensured that `ceil(DIM_RATE_bsa*rand*dim)` for `num_dims_to_mutate` results in at least 1 dimension being mutated, and that `u_bsa(1:min(dim, num_dims_to_mutate))` doesn't go out of bounds if `num_dims_to_mutate` somehow exceeds `dim`.

This version now includes the BSA-inspired recombination as an additional operator that acts on the candidate solutions generated by CGPLO's own mechanisms. This should provide a different kind of exploration/exploitation dynamic. Remember that adding more operators can increase computational cost per iteration, and the interaction between many operators can sometimes lead to complex dynamics that might require further tuning

**Key Changes for "Two Clean Innovations":**

1.  **Function Name:** `CGPLO_DR`.
2.  **Removed Centroid-Based PG:** The previous Population Generator that created new particles based on `center1 + rand_scalar * dis_vec` is completely removed.
3.  **Innovation 1 (CG-AW):**
    * The clustering mechanism and the cluster-guided Aurora Oval Walk are preserved as the first distinct innovation.
4.  **Innovation 2 (BSA-DR):**
    * A historical population `historyX` is maintained, updated from `X` (the elite population from the previous generation) with probability `history_update_prob`, and then shuffled.
    * After the Particle Collision step, the BSA-DR operator is applied to *all* particles in `current_newX`.
    * A `map_bsa_dr` is generated (similar to BSA's map) to select dimensions for modification.
    * A scaling factor `F_bsa_dr` is generated (e.g., `3*randn`).
    * The update rule is: `current_newX = current_newX + F_bsa_dr * (map_bsa_dr .* (historyX - current_newX));`
        * Note: `F_bsa_dr` is a scalar here. If you want per-particle F, `get_scale_factor_bsa_dr` would need to return a vector/matrix, or be called inside a loop. The BSA example uses a scalar F applied to all.
        * The `map_bsa_dr .* ...` ensures only selected dimensions are changed.
    * A BSA-style boundary control `BoundaryControl_bsa_dr` is applied.
5.  **Parameter Naming:** BSA-DR related internal parameters and helper functions are suffixed with `_bsa_dr` for clarity.

This structure provides a clear distinction:
* **Base PLO:** Initialization, basic Aurora Walk (without cluster guidance), Particle Collision, Evaluation.
* **Innovation 1 (CG-AW):** Adds clustering and modifies the Aurora Walk's guidance.
* **Innovation 2 (BSA-DR):** Adds a new, powerful differential recombination step using historical information.

This should be much better suited for your ablation study, as you can test:
* Base PLO
* Base PLO + Innovation 1
* Base PLO + Innovation 2
* Base PLO + Innovation 1 + Innovation 2 (which is `CGPLO_DR`)


I've placed the comment `%% -- Algorithm Operator --` before lines where:
- A new solution vector is generated (e.g., `newX_i = ...`, `X(i,:) = lb_vec + ...`).
- An existing solution vector or its component is modified (e.g., `collided_X_i(j_dim) = ...`, `current_newX = current_newX + ...`).
- Boundary control directly changes solution components.
- Population `X` or `historyX` is updated through assignment or shuffling, as these effectively change the set of solutions or their order for subsequent operations.

This should help you clearly identify the core solution update steps for your ablation study. I also renamed the input variable `X` in `BoundaryControl_bsa_dr` to `X_in` and the output to `X_out` to avoid potential confusion and MATLAB's variable-in-place modification warnings, which is good practi


CDPLO: Centroid (or Cluster) Differential Particle Light Optimization
PLO with Cluster-guidance and Differential Recombination